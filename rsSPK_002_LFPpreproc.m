%% Preprocessing of the LFP - from .mda file to power + coherency
%-
%- Require fieldtrip and other stuff..
%-
%- Author: Fred M. Stoll, Icahn School of Medicine at Mount Sinai, NY
%- Date: 2022.12

clear

%- Add path to fieldtrip here!!
addpath('C:\Users\Fred\Dropbox\Rudebeck Lab\SCRIPTS\fieldtrip-master\')
ft_defaults

path2go = 'I:\Havoc_REC\'; %- data path

%% Create lfp files for each session. No need to run that more than once!

skip = true;

if ~skip
    clear

    session = input('Session to convert into .mat files : ','s');
    cd([path2go session]);

    %- Converting .pl2 files in .MAT files (includes subpsampling at 1000Hz)
    list = dir([session '_spl_WB*.mda']);
    LFP.trial{1} = [];
    for i = 1 : length(list)

        disp('------------------------------------');
        disp(['Processing elec ' num2str(i) '/' num2str(length(list))]);

        raw=readmda(list(i).name);

        data = single(raw);
        clear raw

        %- FT format
        data_lfp.label{1} = num2str(i);
        data_lfp.fsample = 40000;
        data_lfp.time{1} = single([1:length(data)] * (1/data_lfp.fsample));
        data_lfp.trial{1} = data;
        data_lfp.sampleinfo(1,:)=[1 length(data)];
        clear data

        %- subsampling at 1000Hz
        cfg = [];
        cfg.resamplefs = 1000;
        cfg.detrend = 'no';
        [data_lfp] = ft_resampledata(cfg, data_lfp);

        LFP.label{i,1} =  num2str(i);
        LFP.time{1} = data_lfp.time{1};
        LFP.fsample = data_lfp.fsample;
        LFP.trial{1} = [LFP.trial{1} ; data_lfp.trial{1}];
        LFP.sampleinfo(1,:) = [1 length(data_lfp.trial{1})];

    end
    save([session '_lfp.mat'],'LFP','-v7.3')

end
%% Elec rejections. This is based on the visual inspection of the bipolar referenced signal..

session_reject = {'L082522a' 'L090122a' 'L081822b' 'L090822a' 'L092222a' 'H041422a' 'H051222a' 'H042122a' 'H052422a' 'H060322a'}
elec_reject = {[4 5 14 15] [1 2 26 27] [14 15 43 44] [6 7 37 38] [36 37] [7 8 17 18 19 20] [] [] [4 5] [11 12 16 17]};
save([path2go 'rsSPK_elecreject.mat'],'elec_reject','session_reject')

%% Extract LFP for freq decomposition over shorter trials + coherency
clear
sessions = {'L082522a' 'L090122a' 'L081822b' 'L090822a' 'L092222a' 'H041422a' 'H051222a' 'H042122a' 'H052422a' 'H060322a'}

for sss = 1 : length(sessions)

    clearvars -except sessions sss

    session = sessions{sss};
    cd([path2go session]);

    %- load the lfp files (generated by the bit of script above from mda files)
    load([session '_lfp.mat'],'LFP')

    ref = 'bipol'; % 'avgref' or 'bipol' referencing

    if strcmp(ref,'avgref')
        amg = mean(LFP.trial{1}(1:16,:));
        vlpfc = mean(LFP.trial{1}(17:32,:));

        LFP.trial{1} = [LFP.trial{1}(1:16,:)-repmat(amg,16,1) ; LFP.trial{1}(1:16,:)-repmat(vlpfc,16,1)] ;

    elseif strcmp(ref,'bipol')
        dumm = diff(LFP.trial{1});
        rmv_interelec = 16:16:size(dumm,1) ;
        dumm(rmv_interelec,:)=[];% remove the bipol between e16 and 17 (they are on 2 different probes)

        LFP.trial{1} = dumm;
        LFP.label = LFP.label(1:size(dumm,1));

        clear dumm
    end

    %- find events
    list_evt = dir(['*KBD*.mat']);

    evts = [];
    for i = 1 : length(list_evt)
        load([list_evt(i).name])
        if strcmp(session,'H051222a') & i == 1% 2 mistake code in KBD2
            EVT = EVT(end);
        end
        evts = [evts , EVT];
    end
    evts = sortrows(evts'); %- sort them, normally 1 event in each, first one is the injection time, second is the start post-injection window

    %- to look at the signal for electrode rejection
    % LFP.time{1} = double(LFP.time{1});
    % LFP.trial{1} = double(LFP.trial{1});
    % cfg=[];
    % cfg = ft_databrowser(cfg,LFP)

    %% create trials for PRE/POST

    tr_length = 4; % in sec
    evt_BL = [0:tr_length:evts(1)-tr_length]';
    evt_POST = [evts(end):tr_length:LFP.time{1}(end)-tr_length]';

    nPerm = 100;
    tr_length = 4;
    n_tr = 50;
    n_fail = 1000000; %- nb of time it will try to create the trials!

    %- trial permutations for BL period .. trials must not overlap in time (hence the while loop below!!)
    for p = 1 : nPerm %- do that 100 times!
        sess_length = floor(evts(1))-tr_length;
        t=1;n=0;
        disp('Creating non overlapping events')
        while t>0 & n<n_fail
            n = n + 1;
            evt = sortrows(randperm(sess_length,n_tr)');
            t = sum(diff(evt)<=tr_length);
        end
        if n == n_fail
            error('Failed to create non-overlapping trials after trying 1000000 times!! Try running it again!')
        else
            disp('Done!')
        end
        perm(p).evt_BL = evt;
    end

    %- trial permutations for POST period .. trials must not overlap in time (hence the while loop below!!)
    for p = 1 : nPerm %- do that 100 times!

        sess_length = floor(LFP.time{1}(end)-evts(2)-tr_length);
        t=1;n=0;
        disp('Creating non overlapping events')
        while t>0 & n<n_fail
            n = n + 1;
            evt = sortrows(randperm(sess_length,n_tr)');
            t = sum(diff(evt)<=tr_length);
        end
        if n == n_fail
            error('Failed to create non-overlapping trials after trying 1000000 times!! Try running it again!')
        else
            disp('Done!')
        end
        perm(p).evt_POST = evts(2) + evt;
    end

    %- FC for baseline
    for p =  1:nPerm
        clear data_lfp

        data_lfp.label = LFP.label;
        data_lfp.fsample = 1000;

        timestamps = [perm(p).evt_BL ];

        for tr = 1 : length(timestamps)
            tt = find(LFP.time{1}>= timestamps(tr,1),1,'first');

            data_lfp.trial{tr} = LFP.trial{1}(:, tt:tt+(tr_length*1000)-1);
            data_lfp.time{tr} = double((0:(tr_length*1000)-1)/1000);
            data_lfp.sampleinfo(tr,1)=  tt;   %timestamps(tr,:);
            data_lfp.sampleinfo(tr,2)=  tt+(tr_length*1000)-1;   %timestamps(tr,:);
            data_lfp.cfg.trl(tr,:) = [data_lfp.sampleinfo(tr,:) data_lfp.sampleinfo(tr,1)-data_lfp.sampleinfo(tr,2)];
        end

        %- permutation (signal for every elec is from a different time bin..)
        for n = 1: length(LFP.label)
            ord = randperm(length(perm(p).evt_BL));
            timestamps_perm{n} = [perm(p).evt_BL(ord)];
        end

        clear data_lfp_perm

        data_lfp_perm.label = LFP.label;
        data_lfp_perm.fsample = 1000;

        for tr = 1 : length(timestamps)
            for n = 1: length(LFP.label)
                tt = find(LFP.time{1}>= timestamps_perm{n}(tr,1),1,'first');
                data_lfp_perm.trial{tr}(n,:) = LFP.trial{1}(n,tt:tt+(tr_length*1000)-1);
            end
            data_lfp_perm.time{tr} = double((0:(tr_length*1000)-1)/1000);
            data_lfp_perm.sampleinfo(tr,1)=  tt ;   %timestamps(tr,:);
            data_lfp_perm.sampleinfo(tr,2)=  tt+(tr_length*1000)-1 ;   %timestamps(tr,:);
            data_lfp_perm.cfg.trl(tr,:) = [data_lfp_perm.sampleinfo(tr,:) data_lfp_perm.sampleinfo(tr,1)-data_lfp_perm.sampleinfo(tr,2)];
        end

        %- some quick filtering
        cfg=[];
        cfg.bsfilter = 'yes';
        cfg.bsfreq = [59 61 ; 119 121 ; 179 181];
        cfg.lpfilter = 'yes'; % low pass filter
        cfg.lpfreq = 200;
        cfg.hpfilter = 'yes'; % high pass filter
        cfg.hpfreq = 1;
        data_filtered = ft_preprocessing(cfg,data_lfp);

        %- fourier transform (no time info kept)
        cfg            = [];
        cfg.method     = 'mtmfft';
        cfg.output     = 'fourier';
        cfg.keeptrials = 'yes';
        cfg.tapsmofrq  = 1;
        cfg.foi        = [1:.5:100];
        freq(p) = ft_freqanalysis(cfg, data_filtered);

        cfg.keeptrials = 'no';
        fd(p)=ft_freqdescriptives(cfg,freq(p));

        %- imaginary part of the coherency
        cfg         = [];
        cfg.method  ='coh';
        cfg.complex = 'absimag';
        coh_conn(p) = ft_connectivityanalysis(cfg, freq(p));

        %- some quick filtering
        cfg=[];
        cfg.bsfilter = 'yes';
        cfg.bsfreq = [59 61 ; 119 121 ; 179 181];
        cfg.lpfilter = 'yes'; % low pass filter 
        cfg.lpfreq = 200;
        cfg.hpfilter = 'yes'; % high pass filter
        cfg.hpfreq = 1;
        data_filtered_perm = ft_preprocessing(cfg,data_lfp_perm);

        %- fourier transform for permut
        cfg            = [];
        cfg.method     = 'mtmfft';
        cfg.output     = 'fourier';
        cfg.keeptrials = 'yes';
        cfg.tapsmofrq  = 1;
        cfg.foi        = [1:.5:100];
        freq_perm(p) = ft_freqanalysis(cfg, data_filtered_perm);

        cfg.keeptrials = 'no';
        fd_perm(p)=ft_freqdescriptives(cfg,freq_perm(p));

        %- imaginary part of the coherency
        cfg         = [];
        cfg.method  ='coh';
        cfg.complex = 'absimag';
        coh_perm_conn(p) = ft_connectivityanalysis(cfg, freq_perm(p));
    end

    %- extract the average + std across the X trial permutations for each measure
    clear dumm1 dumm2
    for p = 1 : length(perm)
        dumm1(p,:,:)=fd(p).powspctrm;
        dumm2(p,:,:)=fd_perm(p).powspctrm;
    end
    fft_pre.powspctrm = squeeze(nanmean(dumm1,1));
    fft_pre.powspctrm_std = squeeze(std(dumm1,1));
    fft_pre.powspctrm_perm = squeeze(nanmean(dumm2,1));
    fft_pre.powspctrm_perm_std = squeeze(std(dumm2,1));

    measures = {'coh' 'coh_perm'};
    for i = 1 : length(measures)
        clear dumm
        for p = 1 : length(perm)
            if strcmp(measures{i},'coh_perm') %- name of mat is different for perm...
                eval(['dumm(p,:,:,:) = ' measures{i} '_conn(p).' measures{i}(1:3) 'spctrm;'])
            else
                eval(['dumm(p,:,:,:) = ' measures{i} '_conn(p).' measures{i} 'spctrm;'])
            end
        end
        dumm_std = squeeze(std(dumm,1));
        dumm = squeeze(nanmean(dumm,1));
        eval(['conn.' measures{i} ' = dumm;']);
        eval(['conn.' measures{i} '_std = dumm_std;']);
    end
    conn.label = coh_conn(1).label;
    conn.freq = coh_conn(1).freq;

    % same for POST
    for p =  1:nPerm
        clear data_lfp

        data_lfp.label = LFP.label;
        data_lfp.fsample = 1000;

        timestamps = [perm(p).evt_POST ];

        for tr = 1 : length(timestamps)
            tt = find(LFP.time{1}>= timestamps(tr,1),1,'first');

            data_lfp.trial{tr} = LFP.trial{1}(:, tt:tt+(tr_length*1000)-1);
            data_lfp.time{tr} = double((0:(tr_length*1000)-1)/1000);
            data_lfp.sampleinfo(tr,1)=  tt;   %timestamps(tr,:);
            data_lfp.sampleinfo(tr,2)=  tt+(tr_length*1000);   %timestamps(tr,:);
            data_lfp.cfg.trl(tr,:) = [data_lfp.sampleinfo(tr,:) data_lfp.sampleinfo(tr,1)-data_lfp.sampleinfo(tr,2)];
        end

        %- permutation (signal for every elec is from a different time bin..)
        for n = 1: length(LFP.label)
            ord = randperm(length(perm(p).evt_POST));
            timestamps_perm{n} = [perm(p).evt_POST(ord)];
        end

        clear data_lfp_perm

        data_lfp_perm.label = LFP.label;
        data_lfp_perm.fsample = 1000;

        for tr = 1 : length(timestamps)
            for n = 1: length(LFP.label)
                tt = find(LFP.time{1}>= timestamps_perm{n}(tr,1),1,'first');
                data_lfp_perm.trial{tr}(n,:) = LFP.trial{1}(n,tt:tt+(tr_length*1000)-1);
            end
            data_lfp_perm.time{tr} = double((0:(tr_length*1000)-1)/1000);
            data_lfp_perm.sampleinfo(tr,1)=  tt ;   %timestamps(tr,:);
            data_lfp_perm.sampleinfo(tr,2)=  tt+(tr_length*1000) ;   %timestamps(tr,:);
            data_lfp_perm.cfg.trl(tr,:) = [data_lfp_perm.sampleinfo(tr,:) data_lfp_perm.sampleinfo(tr,1)-data_lfp_perm.sampleinfo(tr,2)];
        end


        %- some quick filtering
        cfg=[];
        cfg.bsfilter = 'yes';
        cfg.bsfreq = [59 61 ; 119 121 ; 179 181];
        cfg.lpfilter = 'yes'; % low pass filter 
        cfg.lpfreq = 200;
        cfg.hpfilter = 'yes'; % high pass filter
        cfg.hpfreq = 1;
        data_filtered = ft_preprocessing(cfg,data_lfp);

        %- fourier transform (no time info kept)
        cfg            = [];
        cfg.method     = 'mtmfft';
        cfg.output     = 'fourier';
        cfg.keeptrials = 'yes';
        cfg.tapsmofrq  = 1;
        cfg.foi        = [1:.5:100];
        freq_post(p) = ft_freqanalysis(cfg, data_filtered);

        cfg.keeptrials = 'no';
        fd_post(p)=ft_freqdescriptives(cfg,freq_post(p));

        %- imaginary part of the coherency
        cfg         = [];
        cfg.method  ='coh';
        cfg.complex = 'absimag';
        coh_conn_post(p) = ft_connectivityanalysis(cfg, freq_post(p));

        %- some quick filtering
        cfg=[];
        cfg.bsfilter = 'yes';
        cfg.bsfreq = [59 61 ; 119 121 ; 179 181];
        cfg.lpfilter = 'yes'; % low pass filter 
        cfg.lpfreq = 200;
        cfg.hpfilter = 'yes'; % high pass filter
        cfg.hpfreq = 1;
        data_filtered_perm = ft_preprocessing(cfg,data_lfp_perm);

        %- fourier transform for permut
        cfg            = [];
        cfg.method     = 'mtmfft';
        cfg.output     = 'fourier';
        cfg.keeptrials = 'yes';
        cfg.tapsmofrq  = 1;
        cfg.foi        = [1:.5:100];
        freq_post_perm(p) = ft_freqanalysis(cfg, data_filtered_perm);

        cfg.keeptrials = 'no';
        fd_post_perm(p)=ft_freqdescriptives(cfg,freq_post_perm(p));

        %- imaginary part of the coherency
        cfg         = [];
        cfg.method  ='coh';
        cfg.complex = 'absimag';
        coh_perm_conn_post(p) = ft_connectivityanalysis(cfg, freq_post_perm(p));


    end

    %- extract the average + std across the X trial permutations for each measure
    clear dumm1 dumm2
    for p = 1 : length(perm)
        dumm1(p,:,:)=fd_post(p).powspctrm;
        dumm2(p,:,:)=fd_post_perm(p).powspctrm;
    end
    fft_post.powspctrm = squeeze(nanmean(dumm1,1));
    fft_post.powspctrm_std = squeeze(std(dumm1,1));
    fft_post.powspctrm_perm = squeeze(nanmean(dumm2,1));
    fft_post.powspctrm_perm_std = squeeze(std(dumm2,1));

    measures = {'coh' 'coh_perm'};
    for i = 1 : length(measures)
        clear dumm
        for p = 1 : length(perm)
            if strcmp(measures{i},'coh_perm')
                eval(['dumm(p,:,:,:) = ' measures{i} '_conn_post(p).' measures{i}(1:3) 'spctrm;'])
            else
                eval(['dumm(p,:,:,:) = ' measures{i} '_conn_post(p).' measures{i} 'spctrm;'])
            end
        end
        dumm_std = squeeze(std(dumm,1));
        dumm = squeeze(nanmean(dumm,1));
        eval(['conn_post.' measures{i} ' = dumm;']);
        eval(['conn_post.' measures{i} '_std = dumm_std;']);
    end
    conn_post.label = coh_conn_post(1).label;
    conn_post.freq = coh_conn_post(1).freq;

    data = data_lfp(1);

    %- save matrix
    save([session '_corr_permfilt_' ref '.mat'],'conn','conn_post','fft_pre','fft_post','data','perm')

end
